/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include "math.h"
#include <stdlib.h>
#include <limits.h>

double *
suma_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;

	result = arg1 + arg2 ;

	return &result;
}

double *
resta_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;

	result = arg1 - arg2 ;

	return &result;
}

double *
producto_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;

	result = arg1 * arg2 ;

	return &result;
}

double *
cociente_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;

	result = arg1 / arg2 ;

	return &result;
}

funcion_cuadratica *
ecuaciongradodos_1_svc(int arg1, int arg2, int arg3,  struct svc_req *rqstp)
{
        static funcion_cuadratica  result;
		double x1,x2;
		result.a = arg1;
		result.b = arg2;
		result.c = arg3;

		if(result.a != 0){
			double discriminante = (result.b * result.b) - (4 * result.a * result.c) ;

			if (discriminante < 0){
				result.valor_1 = result.valor_2 = INT_MIN;
			} 
			else{
				double raiz = sqrt(discriminante) ;
				printf("Raiz = %f", raiz);
				x1 = (-result.b + raiz) / (2*result.a) ;
				x2 = (-result.b - raiz)/ (2*result.a) ;
				result.valor_1 = x1;
				result.valor_2 = x2;
			}
		}
		else{
			result.valor_1 = result.valor_2 = (-result.c*1.0)/(result.b*1.0);
		}
		

        return &result;
}


double *
sumaacumuladavector_1_svc(secuencia arg1,  struct svc_req *rqstp)
{
	static double  result;
	result = arg1.secuencia_val[0] * 1.0;

	for (int i = 1 ; i < arg1.secuencia_len ; i++){
		result += (arg1.secuencia_val[i] * 1.0);
	}
	

	return &result;
}

double *
restaacumuladavector_1_svc(secuencia arg1,  struct svc_req *rqstp)
{
	static double  result;

	result = arg1.secuencia_val[0] * 1.0;

	for (int i = 1 ; i < arg1.secuencia_len ; i++){
		result -= (arg1.secuencia_val[i] * 1.0);
	}

	return &result;
}

double *
productoacumuladavector_1_svc(secuencia arg1,  struct svc_req *rqstp)
{
	static double  result;

	result = arg1.secuencia_val[0] * 1.0;

	for (int i = 1 ; i < arg1.secuencia_len ; i++){
		result = result * (arg1.secuencia_val[i] * 1.0);
	}

	return &result;
}

secuencia *
sumavectores_1_svc(secuencia arg1, secuencia arg2,  struct svc_req *rqstp)
{
        static secuencia  result;

        result.secuencia_len = arg1.secuencia_len;
		result.secuencia_val = malloc(result.secuencia_len * sizeof(double));

		for (int i = 0 ; i < result.secuencia_len ; i++){
			result.secuencia_val[i] = arg1.secuencia_val[i] + arg2.secuencia_val[i] ;
		}

        return &result;
}

secuencia *
restavectores_1_svc(secuencia arg1, secuencia arg2,  struct svc_req *rqstp)
{
        static secuencia  result;

        result.secuencia_len = arg1.secuencia_len;
		result.secuencia_val = malloc(result.secuencia_len * sizeof(double));

		for (int i = 0 ; i < result.secuencia_len ; i++){
			result.secuencia_val[i] = arg1.secuencia_val[i] - arg2.secuencia_val[i] ;
		}

        return &result;
}

secuencia *
productovectores_1_svc(secuencia arg1, secuencia arg2,  struct svc_req *rqstp)
{
        static secuencia  result;

        result.secuencia_len = arg1.secuencia_len;
		result.secuencia_val = malloc(result.secuencia_len * sizeof(double));

		for (int i = 0 ; i < result.secuencia_len ; i++){
			result.secuencia_val[i] = arg1.secuencia_val[i] * arg2.secuencia_val[i] ;
		}

        return &result;
}

secuencia *
cocientevectores_1_svc(secuencia arg1, secuencia arg2,  struct svc_req *rqstp)
{
        static secuencia  result;

        result.secuencia_len = arg1.secuencia_len;
		result.secuencia_val = malloc(result.secuencia_len * sizeof(double));

		for (int i = 0 ; i < result.secuencia_len ; i++){
			result.secuencia_val[i] = arg1.secuencia_val[i] / arg2.secuencia_val[i] ;
		}

        return &result;
}

matriz *
sumamatrices_1_svc(matriz arg1, matriz arg2,  struct svc_req *rqstp)
{
        static matriz  result;
		int filas, columnas ;

		filas = arg1.matriz_len;
		columnas = arg1.matriz_val[0].secuencia_len ; 

		result.matriz_len = filas;
 		result.matriz_val = malloc(filas * sizeof(secuencia)) ;

        for (size_t i = 0; i < filas; i++)
		{
			
			secuencia fila;
	  		fila.secuencia_len = columnas ;
	  		fila.secuencia_val = malloc(columnas * sizeof(double));
			result.matriz_val[i] = fila ;

			for (size_t j = 0; j < columnas; j++)
			{
				fila.secuencia_val[j] = arg1.matriz_val[i].secuencia_val[j] + arg2.matriz_val[i].secuencia_val[j] ;
			}
			
			
		}
		

        return &result;
}

matriz *
restamatrices_1_svc(matriz arg1, matriz arg2,  struct svc_req *rqstp)
{
		 static matriz  result;
		int filas, columnas ;

		filas = arg1.matriz_len;
		columnas = arg1.matriz_val[0].secuencia_len ; 

		result.matriz_len = filas;
 		result.matriz_val = malloc(filas * sizeof(secuencia)) ;

        for (size_t i = 0; i < filas; i++)
		{
			
			secuencia fila;
	  		fila.secuencia_len = columnas ;
	  		fila.secuencia_val = malloc(columnas * sizeof(double));
			result.matriz_val[i] = fila ;

			for (size_t j = 0; j < columnas; j++)
			{
				fila.secuencia_val[j] = arg1.matriz_val[i].secuencia_val[j] - arg2.matriz_val[i].secuencia_val[j] ;
			}
			
			
		}
		

        return &result;
}

matriz *
productomatrices_1_svc(matriz arg1, matriz arg2,  struct svc_req *rqstp)
{
         static matriz  result;
		int filas, columnas_a, columnas_b ;

		filas = arg1.matriz_len;
		columnas_a = arg1.matriz_val[0].secuencia_len ; 
		columnas_b = arg2.matriz_val[0].secuencia_len ; 

		result.matriz_len = filas;
 		result.matriz_val = malloc(filas * sizeof(secuencia)) ;

        for (size_t i = 0; i < filas; i++)
		{	
			secuencia fila;
	  		fila.secuencia_len = columnas_b ;
	  		fila.secuencia_val = malloc(columnas_b * sizeof(double));
			result.matriz_val[i] = fila ;	
		}

		// Necesitamos hacer esto por cada columna de la segunda matriz (B)
   		 for (int a = 0; a < columnas_b; a++) {
        // Dentro recorremos las filas de la primera (A)
        for (int i = 0; i < filas; i++) {
            int valor = 0;
            // Y cada columna de la primera (A)
            for (int j = 0; j < columnas_a; j++) {
                // Multiplicamos y sumamos resultado
                valor += arg1.matriz_val[i].secuencia_val[j] * arg1.matriz_val[j].secuencia_val[a];
            }
            // Lo acomodamos dentro del producto
            result.matriz_val[i].secuencia_val[a] = valor;
        }
    }
		
		

        return &result;
}

double *
determinantematrices_1_svc(matriz arg1, struct svc_req *rqstp)
{
        static double  result;

		result = determinante(arg1) ;

        return &result;
}

int determinante(matriz arg1){

	double result = 0.0 ;
	int orden = arg1.matriz_len;

		if(orden == 1){
			result = arg1.matriz_val[0].secuencia_val[0];
		}
		else{
			 for (int j = 0; j < orden; j++) {
         		result = result + arg1.matriz_val[0].secuencia_val[j] * cofactor(arg1, 0, j);
      		}
		}

	return result ;
}
 
 
int cofactor(matriz input, int fila, int columna)
{
   matriz submatriz;
   int orden = input.matriz_len;
   int n = orden - 1;
   int i, j;


   		submatriz.matriz_len = n;
 		submatriz.matriz_val = malloc(n * sizeof(secuencia)) ;

        for (size_t i = 0; i < n; i++)
		{	
			secuencia fila;
	  		fila.secuencia_len = n ;
	  		fila.secuencia_val = malloc(n * sizeof(double));
			submatriz.matriz_val[i] = fila ;	
		}
   
   int x = 0;
   int y = 0;
   for (i = 0; i < orden; i++) {
      for (j = 0; j < orden; j++) {
         if (i != fila && j != columna) {
            submatriz.matriz_val[x].secuencia_val[y] = input.matriz_val[i].secuencia_val[j];
            y++;
            if (y >= n) {
               x++;
               y = 0;
            }
         }
      }
   }
   
   return pow(-1.0, fila + columna) * determinante(submatriz);
}